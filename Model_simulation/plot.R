# phenotype-specific intrinsic growth rates, for one trait dimension
# Input:
# - z: trait value(s); can be a vector
# - bshape: shape of intrinsic growth function
# Output:
# - the intrinsic growth rate(s) of phenotype(s) z
b_intrinsic <- function(z, bshape) {
  th <- 1/2 # the value of theta; set to a constant 1/2
  if (bshape=="b_rectangular") b <- (sign(th+z)+1)*(sign(th-z)+1)/4
  if (bshape=="b_quadratic") b <- 1-z^2/th^2
  if (bshape=="b_triangular") b <- (z+th)/(2*th)*(sign(th+z)+1)*(sign(th-z)+1)/4
  if (bshape=="b_quartic") b <- 1-z^4/th^4
  if (bshape=="b_bimodal") b <- 2*(th^2-z^2)*((3+sqrt(5))*z^2+2*th^2)/(5*th^4)
  return(b)
}

# create data frame with points on the perimeter of an ellipse
# Input:
# - m: two-component vector, with the means in the x- and y-direction
# - P: covariance matrix
# - p: wht fraction of the distribution to show (0 < p < 1)
# Output:
# - a data frame with two columns (x and y) and 501 rows; each row
#   contains the coordinates of one point of the ellipse
ellipseframe <- function(m, P, p) {
  s <- -2*log(1-p)
  eP <- eigen(P*s)
  sqrtP <- eP$vectors %*% diag(sqrt(eP$values)) %*% t(eP$vectors)
  phi <- seq(0, 2*pi, l=501)
  ellipse <- data.frame(x=cos(phi), y=sin(phi))
  for (i in 1:nrow(ellipse)) ellipse[i,] <- sqrtP%*%unlist(ellipse[i,])
  ellipse %>% mutate(x=x+m[1], y=y+m[2]) %>% as_tibble()
}

# plot species' density distributions in trait space (in 1D)
# Input:
# - snap: data generated by "organize_results()" in "solve_eqs.R", restricted
#         to a single point in time (i.e., a snapshot of the dynamics)
# - limits: vector with three entries: lower limit of trait axis, upper limit
#           of trait axis, and upper limit of y-axis. If this last entry is set
#           to NA, the y-axis will be scaled automatically
# - res: resolution of the trait axis, the number of grid points it gets
#        subdivided into to generate the plot
# Output:
# - a plot of the species' density distributions
plot_snapshot <- function(snap, limits=c(-1, 1, NA), res=1001) {
  S <- max(snap$species)
  traitaxis <- seq(limits[1], limits[2], l=res)
  traits <- expand.grid(1:S, traitaxis)
  colnames(traits) <- c("species", "trait")
  traits["density"] <- 0
  for (i in 1:S) {
    n <- filter(snap, species==i)$n
    m <- filter(snap, species==i)$m1
    P <- filter(snap, species==i)$G11
    P <- P + filter(snap, species==i)$E11
    traits$density[(traits$species==i)] <- n *
      dnorm(traits$trait[(traits$species==i)], m, sqrt(P))
    traits$density[(traits$species==i)][
      traits$density[(traits$species==i)]<n*0.001/sqrt(P)] <- NA
  }
  traits$density[traits$density<1e-6] <- NA
  landscape <- data.frame(trait=traitaxis, r=0)
  landscape$r <- b_intrinsic(landscape$trait, snap$bshape[1])
  landscape$r[landscape$r<0] <- NA
  if (is.na(limits[3])) limits[3] <- max(traits$density,na.rm=TRUE)
  landscape$r <- landscape$r * limits[3]
  ggplot(traits) +
    geom_line(aes(x=trait, y=density, group=as_factor(species)),
              colour="#0072B2", na.rm=TRUE) +
    geom_ribbon(aes(x=trait, ymin=0, ymax=density, group=as_factor(species)),
                fill="#0072B2", alpha=0.15) +
    geom_line(data=landscape, aes(x=trait, y=r), linetype="dashed",
              colour="#CC79A7", alpha=0.8, na.rm=TRUE) +
    scale_x_continuous(name="trait value", limits=c(limits[1], limits[2])) +
    scale_y_continuous(name="density", limits=c(0, limits[3]),
                       sec.axis=sec_axis(~./limits[3],
                                         name="intrinsic growth rate",
                                         breaks=c(0, 1))) +
    theme_bw() +
    theme(legend.position="none", panel.grid=element_blank())
}

# plot species' density distributions in trait space (in 2D)
# Input:
# - snap: data generated by "organize_results()" in "solve_eqs.R", restricted
#         to a single point in time (i.e., a snapshot of the dynamics)
# Output:
# - a plot of the species' density distributions
plot_snapshot_2D <- function(snap) {
  S <- max(snap$species)
  L <- 2
  landscape <- ellipseframe(m=c(0,0), P=matrix(c(1,0,0,1), 2, 2), p=0.1175)
  trait <- tibble(sp=integer(), n=numeric(), x=numeric(), y=numeric())
  for (i in 1:S) {
    n <- snap %>% filter(species==i) %>% pull(n)
    m <- (snap %>% filter(species==i))[c("m1", "m2")] %>% as.numeric
    G <- (snap %>% filter(species==i))[c("G11", "G21", "G12", "G22")] %>%
      as.numeric %>% matrix(L,L)
    E <- (snap %>% filter(species==i))[c("E11", "E21", "E12", "E22")] %>%
      as.numeric %>% matrix(L,L)
    P <- G + E
    trait <- bind_rows(trait, ellipseframe(m, P, 0.95) %>% mutate(sp=i, n=n))
  }
  fakem <- c(0, 0)
  fakeP <- matrix(c(0.00001, 0, 0, 0.00001)^2, L, L)
  trait <- bind_rows(trait, ellipseframe(fakem,fakeP,0.01) %>% mutate(sp=0,n=0))
  ntot <- sum((trait%>%group_by(sp)%>%summarise(nmean=mean(n))%>%ungroup)$nmean)
  trait <- trait %>% mutate(sp=as_factor(sp), n=n/ntot)
  ggplot(trait) +
    geom_polygon(aes(x=x, y=y, group=sp, alpha=n, colour=sp, fill=sp)) +
    geom_path(data=landscape, aes(x=x, y=y), colour="#CC79A7",
              alpha=0.9, linetype="dashed") +
    scale_x_continuous(name="trait 1 value", limits=c(-0.5, 0.5),
                       breaks=c(-0.5, -0.25, 0, 0.25, 0.5)) +
    scale_y_continuous(name="trait 2 value", limits=c(-0.5, 0.5),
                       breaks=c(-0.5, -0.25, 0, 0.25, 0.5)) +
    scale_alpha_continuous(range=c(0, 0.6)) +
    scale_colour_manual(values=c("white", rep("#0072B2", S))) +
    scale_fill_manual(values=c("white", rep("#0072B2", S))) +
    theme_bw() +
    theme(legend.position="none", panel.grid=element_blank())
}
