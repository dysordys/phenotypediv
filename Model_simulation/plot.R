
## colorblind-friendly palette
cpal <- c("#999999","#E69F00","#56B4E9","#009E73","#0072B2","#CC79A7","#D55E00")
theme_set(theme_bw()) ## set default ggplot theme


## phenotype-specific intrinsic growth rates, for one trait dimension
## Input:
## - z: trait value(s); can be a vector
## - bshape: shape of intrinsic growth function
## Output:
## - the intrinsic growth rate(s) of phenotype(s) z
b_intrinsic <- function(z, bshape) {
    th <- 1/2 ## the value of theta; set to a constant 1/2
    if (bshape=="b_rectangular") b <- (sign(th+z)+1)*(sign(th-z)+1)/4
    if (bshape=="b_quadratic") b <- 1-z^2/th^2
    if (bshape=="b_triangular") b <- (z+th)/(2*th)*(sign(th+z)+1)*(sign(th-z)+1)/4
    if (bshape=="b_quartic") b <- 1-z^4/th^4
    if (bshape=="b_bimodal") b <- 2*(th^2-z^2)*((3+sqrt(5))*z^2+2*th^2)/(5*th^4)
    return(b)
}

## create data frame with points on the perimeter of an ellipse
## Input:
## - m: two-component vector, with the means in the x- and y-direction
## - P: covariance matrix
## - p: wht fraction of the distribution to show (0 < p < 1)
## Output:
## - a data frame with two columns (x and y) and 501 rows; each row
##   contains the coordinates of one point of the ellipse
ellipseframe <- function(m, P, p) {
    s <- -2*log(1-p)
    eP <- eigen(P*s)
    sqrtP <- eP$vectors %*% diag(sqrt(eP$values)) %*% t(eP$vectors)
    phi <- seq(0, 2*pi, l=501)
    ellipse <- tibble(x=cos(phi), y=sin(phi))
    for (i in 1:nrow(ellipse)) ellipse[i,] <- sqrtP%*%unlist(ellipse[i,])
    ellipse <- ellipse %>% mutate(x=x+m[1], y=y+m[2])
    return(ellipse)
}

## plot species densities in time
## Input:
## - dat: a tibble (data frame) generated by "organize_results()" in "solve_eqs.R"
## Output:
## - a graph of species densities against time
plot_density <- function(dat) {
    dat %>%
        mutate(n=ifelse(n<0, 0, n)) %>%
        ggplot() +
        aes(x=time, y=n, colour=factor(species)) +
        geom_line() +
        scale_x_continuous(name="time") +
        scale_y_continuous(name="population density", limits=c(0, NA)) +
        scale_colour_manual(values=rep(cpal,ceiling(S/length(cpal)))[1:S])+
        theme(legend.position="none") %>%
        return
}

## plot species' trait means in time
## Input:
## - dat: a tibble (data frame) generated by "organize_results()" in "solve_eqs.R"
## Output:
## - a graph of species' trait means against time
plot_trait <- function(dat) {
    dat %>%
        ggplot() +
        aes(x=time,y=m1,ymin=m1-sqrt(G11),ymax=m1+sqrt(G11),fill=factor(species)) +
        geom_ribbon(alpha=0.15) +
        geom_line(aes(colour=factor(species))) +
        scale_x_continuous(name="time") +
        scale_y_continuous(name="trait value") +
        scale_colour_manual(values=rep(cpal,ceiling(S/length(cpal)))[1:S])+
        scale_fill_manual(values=rep(cpal, ceiling(S/length(cpal)))[1:S])+
        theme(legend.position="none") %>%
        return
}

## plot species' density distributions in trait space (in 1D)
## Input:
## - snap: data generated by "organize_results()" in "solve_eqs.R", restricted
##         to a single point in time (i.e., a snapshot of the dynamics)
## - limits: vector with three entries: lower limit of trait axis, upper limit
##           of trait axis, and upper limit of y-axis. If this last entry is set
##           to NA, the y-axis will be scaled automatically
## - res: resolution of the trait axis, the number of grid points it gets
##        subdivided into to generate the plot
## Output:
## - a plot of the species' density distributions
plot_snapshot <- function(snap, limits=c(-1, 1, NA), res=1001) {
    S <- max(snap$species)
    traitaxis <- seq(limits[1], limits[2], l=res)
    traits <- expand.grid(1:S, traitaxis)
    colnames(traits) <- c("species", "trait")
    traits["density"] <- 0
    for (i in 1:S) {
        n <- filter(snap, species==i)$n
        m <- filter(snap, species==i)$m1
        P <- filter(snap, species==i)$G11
        P <- P + filter(snap, species==i)$E11
        traits$density[(traits$species==i)] <- n *
            dnorm(traits$trait[(traits$species==i)], m, sqrt(P))
        traits$density[(traits$species==i)][
                   traits$density[(traits$species==i)]<n*0.001/sqrt(P)] <- NA
    }
    traits$density[traits$density<1e-6] <- NA
    landscape <- data.frame(trait=traitaxis, r=0)
    landscape$r <- b_intrinsic(landscape$trait, snap$bshape[1])
    landscape$r[landscape$r<0] <- NA
    if (is.na(limits[3])) limits[3] <- max(traits$density,na.rm=TRUE)
    landscape$r <- landscape$r * limits[3]
    return(ggplot(traits) +
           geom_line(aes(x=trait, y=density, colour=factor(species)), na.rm=TRUE) +
           geom_ribbon(aes(x=trait, ymin=0, ymax=density, fill=factor(species)),
                       alpha=0.15) +
           geom_line(data=landscape, aes(x=trait, y=r), linetype="dashed",
                     colour=cpal[7], alpha=0.8, na.rm=TRUE) +
           scale_x_continuous(name="trait value", limits=c(limits[1], limits[2])) +
           scale_y_continuous(name="density", limits=c(0, limits[3]),
                              sec.axis=sec_axis(~./limits[3],
                                                name="intrinsic growth rate",
                                                breaks=c(0, 1))) +
           scale_colour_manual(values=rep(cpal, ceiling(S/length(cpal)))[1:S]) +
           scale_fill_manual(values=rep(cpal, ceiling(S/length(cpal)))[1:S]) +
           theme(legend.position="none",
                 strip.background=element_rect(fill="#CCCCFF")))
}

## plot species' density distributions in trait space (in 2D)
## Input:
## - snap: data generated by "organize_results()" in "solve_eqs.R", restricted
##         to a single point in time (i.e., a snapshot of the dynamics)
## Output:
## - a plot of the species' density distributions
plot_snapshot_2D <- function(snap) {
    S <- max(snap$species)
    L <- 2
    landscape <- ellipseframe(m=c(0,0), P=matrix(c(1,0,0,1), 2, 2), p=0.1175)
    trait <- tibble(sp=integer(), n=numeric(), x=numeric(), y=numeric())
    for (i in 1:S) {
        n <- snap %>% filter(species==i) %>% pull(n)
        m <- (snap %>% filter(species==i))[c("m1", "m2")] %>% as.numeric
        G <- (snap %>% filter(species==i))[c("G11", "G21", "G12", "G22")] %>%
            as.numeric %>% matrix(L,L)
        E <- (snap %>% filter(species==i))[c("E11", "E21", "E12", "E22")] %>%
            as.numeric %>% matrix(L,L)
        P <- G + E
        trait <- bind_rows(trait, ellipseframe(m, P, 0.95) %>% mutate(sp=i, n=n))
    }
    fakem <- c(0, 0)
    fakeP <- matrix(c(0.00001, 0, 0, 0.00001)^2, L, L)
    trait <- bind_rows(trait, ellipseframe(fakem,fakeP,0.01) %>% mutate(sp=0,n=0))
    ntot <- sum((trait %>% group_by(sp) %>% summarise(nmean=mean(n)))$nmean)
    trait <- trait %>% mutate(sp=as.factor(sp), n=n/ntot)
    return(ggplot(trait) +
           geom_polygon(aes(x=x, y=y, colour=sp, fill=sp, alpha=n)) +
           geom_path(aes(x=x, y=y, colour=sp), alpha=0.3) +
           geom_path(data=landscape, aes(x=x, y=y), colour="darkred",
                     alpha=0.5, linetype="dashed") +
           scale_x_continuous(name="trait 1", limits=c(-0.5, 0.5),
                              breaks=c(-0.5, -0.25, 0, 0.25, 0.5)) +
           scale_y_continuous(name="trait 2", limits=c(-0.5, 0.5),
                              breaks=c(-0.5, -0.25, 0, 0.25, 0.5)) +
           scale_alpha_continuous(range=c(0, 0.8)) +
           scale_colour_manual(values=c("#FFFFFF", rep(cpal,
                                          ceiling(S/length(cpal)))[1:S])) +
           scale_fill_manual(values=c("#FFFFFF", rep(cpal,
                                        ceiling(S/length(cpal)))[1:S])) +
           theme(legend.position="none"))
}
