# colorblind-friendly palette
cpal <- c("#999999","#E69F00","#56B4E9","#009E73","#0072B2","#CC79A7","#D55E00")


# phenotype-specific intrinsic growth rates, for one trait dimension
# Input:
# - z: trait value(s); can be a vector
# - bshape: shape of intrinsic growth function
# Output:
# - the intrinsic growth rate(s) of phenotype(s) z
b_intrinsic <- function(z, bshape) {
  th <- 1/2 # the value of theta; set to a constant 1/2
  if (bshape=="b_rectangular") b <- (sign(th+z)+1)*(sign(th-z)+1)/4
  if (bshape=="b_quadratic") b <- 1-z^2/th^2
  if (bshape=="b_triangular") b <- (z+th)/(2*th)*(sign(th+z)+1)*(sign(th-z)+1)/4
  if (bshape=="b_quartic") b <- 1-z^4/th^4
  if (bshape=="b_bimodal") b <- 2*(th^2-z^2)*((3+sqrt(5))*z^2+2*th^2)/(5*th^4)
  return(b)
}

# create data frame with points on the perimeter of an ellipse
# Input:
# - m: two-component vector, with the means in the x- and y-direction
# - P: covariance matrix
# - p: wht fraction of the distribution to show (0 < p < 1)
# Output:
# - a data frame with two columns (x and y) and 501 rows; each row
#   contains the coordinates of one point of the ellipse
ellipseframe <- function(m, P, p) {
  s <- -2*log(1-p)
  eP <- eigen(P*s)
  sqrtP <- eP$vectors %*% diag(sqrt(eP$values)) %*% t(eP$vectors)
  phi <- seq(0, 2*pi, l=501)
  ellipse <- data.frame(x=cos(phi), y=sin(phi))
  for (i in 1:nrow(ellipse)) ellipse[i,] <- sqrtP%*%unlist(ellipse[i,])
  ellipse %>% mutate(x=x+m[1], y=y+m[2]) %>% as_tibble()
}

# plot species densities in time
# Input:
# - dat: a tibble (data frame) generated by "organize_results()" in "solve_eqs.R"
# Output:
# - a graph of species densities against time
plot_density <- function(dat) {
  dat %>%
    mutate(n=ifelse(n<0, 0, n)) %>%
    ggplot() +
    aes(x=time, y=n, colour=factor(species)) +
    geom_line() +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="population density", limits=c(0, NA)) +
    scale_colour_manual(values=rep(cpal,ceiling(S/length(cpal)))[1:S]) +
    theme_bw() +
    theme(legend.position="none")
}

# plot species' trait means in time
# Input:
# - dat: a tibble (data frame) generated by "organize_results()" in "solve_eqs.R"
# Output:
# - a graph of species' trait means against time
plot_trait <- function(dat) {
  dat %>%
    ggplot() +
    aes(x=time,y=m1,ymin=m1-sqrt(G11),ymax=m1+sqrt(G11),fill=factor(species)) +
    geom_ribbon(alpha=0.15) +
    geom_line(aes(colour=factor(species))) +
    scale_x_continuous(name="time") +
    scale_y_continuous(name="trait value") +
    scale_colour_manual(values=rep(cpal,ceiling(S/length(cpal)))[1:S]) +
    scale_fill_manual(values=rep(cpal, ceiling(S/length(cpal)))[1:S]) +
    theme_bw() +
    theme(legend.position="none")
}

# Make a plot of the trait distributions at some given moment
# Input:
# - dat: data generated by organize_results, defined in solve_eqs.R
# - moment: at which time point should the community state be plotted
# - limits: a vector of three entries (x_low, x_high, y_high) for the plot
#           range limits (note: the lower limit for the y-axis is always
#           equal to 0); set them to NA to determine them automatically
# - res: number of evenly spaced sampling points along the trait axis
# - b: a function, giving the rate of intrinsic growth for any given trait
# Output:
# - a ggplot2 plot
plot_snapshot <- function(dat, moment=0, limits=c(NA, NA, NA), res=501, b) {
  if (!is.na(moment)) {
    snap <- filter(dat, time==moment) %>% select(-time) # time = moment
  } else {
    snap <- dat
  }
  species <- unique(snap$species) # the set of species present at time = moment
  xlimits <- range(c(snap$m-4*snap$s, snap$m+4*snap$s))
  if (is.na(limits[1])) limits[1] <- xlimits[1]
  if (is.na(limits[2])) limits[2] <- xlimits[2]
  traitaxis <- seq(limits[1], limits[2], l=res) # sampling the trait axis
  traits <- expand_grid(species=species, trait=traitaxis) # trait tab
  traits["density"] <- 0 # add column for population densities
  for (i in species) {
    v <- snap %>% filter(species==i) %>% select(n, m, s)
    traits$density[(traits$species==i)] <- v$n * # trait normally distributed,
      dnorm(traits$trait[(traits$species==i)], v$m, v$s) # times density
    traits$density[(traits$species==i)][ # points > m +/- 3*sigma: set to NA
      traits$density[(traits$species==i)]<v$n*0.001/v$s] <- NA
  }
  traits$density[traits$density<1e-6] <- NA # points below ext. threshold: NA
  landscape <- tibble(trait=traitaxis, r=0) # for plotting intrinsic rates
  landscape$r <- b(landscape$trait)
  landscape$r[landscape$r<0] <- NA # where b(z) < 0: set to NA
  # scale the result so that it will show nicely on the plot
  if (is.na(limits[3])) landscape$r <- landscape$r*max(traits$density,na.rm=TRUE)
  if (!is.na(limits[3])) landscape$r <- landscape$r * limits[3] * 0.98
  ggplot(traits) + # generate plot
    geom_line(aes(x=trait, y=density, group=factor(species)),
              colour="#0072B2", na.rm=TRUE) +
    geom_ribbon(aes(x=trait, ymin=0, ymax=density, group=factor(species)),
                fill="#0072B2", alpha=0.15) +
    geom_line(data=landscape, aes(x=trait, y=r), linetype="dashed",
              colour="darkred", alpha=0.5, na.rm=TRUE) +
    scale_x_continuous(name="trait value", limits=c(limits[1], limits[2])) +
    scale_y_continuous(name="density", limits=c(0, limits[3])) +
    theme_bw() +
    theme(panel.grid=element_blank(), legend.position="none")
}

# plot species' density distributions in trait space (in 2D)
# Input:
# - snap: data generated by "organize_results()" in "solve_eqs.R", restricted
#         to a single point in time (i.e., a snapshot of the dynamics)
# Output:
# - a plot of the species' density distributions
plot_snapshot_2D <- function(snap) {
  S <- max(snap$species)
  L <- 2
  landscape <- ellipseframe(m=c(0,0), P=matrix(c(1,0,0,1), 2, 2), p=0.1175)
  trait <- tibble(sp=integer(), n=numeric(), x=numeric(), y=numeric())
  for (i in 1:S) {
    n <- snap %>% filter(species==i) %>% pull(n)
    m <- (snap %>% filter(species==i))[c("m1", "m2")] %>% as.numeric
    G <- (snap %>% filter(species==i))[c("G11", "G21", "G12", "G22")] %>%
      as.numeric %>% matrix(L,L)
    E <- (snap %>% filter(species==i))[c("E11", "E21", "E12", "E22")] %>%
      as.numeric %>% matrix(L,L)
    P <- G + E
    trait <- bind_rows(trait, ellipseframe(m, P, 0.95) %>% mutate(sp=i, n=n))
  }
  fakem <- c(0, 0)
  fakeP <- matrix(c(0.00001, 0, 0, 0.00001)^2, L, L)
  trait <- bind_rows(trait, ellipseframe(fakem,fakeP,0.01) %>% mutate(sp=0,n=0))
  ntot <- sum((trait%>%group_by(sp)%>%summarise(nmean=mean(n))%>%ungroup)$nmean)
  trait <- trait %>% mutate(sp=as.factor(sp), n=n/ntot)
  ggplot(trait) +
    geom_polygon(aes(x=x, y=y, colour=sp, fill=sp, alpha=n)) +
    geom_path(aes(x=x, y=y, colour=sp), alpha=0.3) +
    geom_path(data=landscape, aes(x=x, y=y), colour="darkred",
              alpha=0.5, linetype="dashed") +
    scale_x_continuous(name="trait 1", limits=c(-0.5, 0.5),
                       breaks=c(-0.5, -0.25, 0, 0.25, 0.5)) +
    scale_y_continuous(name="trait 2", limits=c(-0.5, 0.5),
                       breaks=c(-0.5, -0.25, 0, 0.25, 0.5)) +
    scale_alpha_continuous(range=c(0, 0.8)) +
    scale_colour_manual(values=c("#FFFFFF", rep(cpal,
                                                ceiling(S/length(cpal)))[1:S])) +
    scale_fill_manual(values=c("#FFFFFF", rep(cpal,
                                              ceiling(S/length(cpal)))[1:S])) +
    theme_bw() +
    theme(legend.position="none")
}
